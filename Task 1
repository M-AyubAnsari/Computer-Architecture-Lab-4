.text
.globl

Factorial:
    addi sp, sp, -8       # Allocating the stack
    sw x1, 4(sp)          # Storing the return address at register x1
    sw x10, 0(sp)         # Storing the value of n at the return register x10 that will be updated each iteration

    addi x3, x0, 1          # The value of 1 is stored at register x3
    addi x4, x10, 5         # The value of n is assigned to register x4 for loop operations

LOOP:
    beq x4, x0, END1       # Condtion jump if n = 0 
    mul x3, x3, x4         # x3 now holds the value of the multiplying n with the result
    addi x4, x4, -1        # Decrementing n after each loop, x4 = x4 + (-1)
    jal x0, LOOP           # Jump tp loop and it keeps on iterating until the condition of n = 0 is met

END1:
    addi x10, x3, 0         # The result of the loop is now stored in the return register
    lw x1, 4(sp)            # Restore the return address
    addi sp, sp, 8          # Deallocating the stack
    jalr x0, x1, 0          # Exits the function and returns to the original function call line.
